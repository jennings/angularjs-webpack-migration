<p>
    This project is a demonstration of how to migrate an AngularJS app from
    a hand-spun build process to webpack.
</p>

<h2>Bundling JavaScript</h2>
<p>
    The JavaScript is bundled using webpack. The npm package
    <code>webpack-stream</code> creates a gulp stream out of webpack's output.
</p>
<p>
    webpack knows the entry point of the application, and it follows the calls
    to <code>require()</code> to learn what other files need to be bundled.
    This means the build script no longer needs to know what order to bundle
    files. As long as <code>require()</code> is used at the right places, files
    will be bundled in a correct order.
</p>

<h2>Compiling templates</h2>
<p>
    The AngularJS templates are compiled and added to the template cache by the
    npm package <code>gulp-angular-templatecache</code>. The output of that
    plugin is concatenated with the rest of the JavaScript before minification.
</p>

<h2>CSS</h2>
<p>
    Any files matching the following patterns are fed to
    <code>gulp-sass</code>:
</p>
<ul>
    <li><code>node_modules/boostrap/dist/css/bootstrap.min.css</code></li>
    <li><code>src/**/*.scss</code></li>
</ul>
<p>
    The output of <code>gulp-sass</code> is concatenated and saved to
    <code>bundle.css</code>.
</p>
<p>
    Again, <strong>the order of bundling matters</strong>. Styles defined in
    later stylesheets override those in previous ones. If we had many SCSS
    files, we could run into issues where they don't get concatenated in the
    order we expect.
</p>

<h2>Development server</h2>
<p>
    The development server is Browsersync. Once all the JavaScript, CSS, and
    other assets are bundled and placed in <code>./dist</code>,
    Browsersync serves files out of that directory.
</p>
<p>
    A gulp watch is placed on the input files. If any change, the appropriate
    gulp task is executed, then Browsersync reloads the page in the browser.
</p>
